from google.colab import drive
drive.mount('/content/drive')

import os
import cv2
import numpy as np
import matplotlib.pyplot as plt
from sklearn.mixture import GaussianMixture

____________________________________________________________________________________________________

# 이미지 불러오기
img = cv2.imread("/content/drive/MyDrive/Colab/ACK2025/passion_fruit/OpenCV_data/N_3.JPG")
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# GrabCut으로 과실 전체 추출
mask = np.zeros(img.shape[:2], np.uint8)
bgdModel = np.zeros((1, 65), np.float64)
fgdModel = np.zeros((1, 65), np.float64)

height, width = img.shape[:2]
margin_x = int(width * 0.04)
margin_y = int(height * 0.04)
rect = (margin_x, margin_y, width - 2 * margin_x, height - 2 * margin_y)

cv2.grabCut(img, mask, rect, bgdModel, fgdModel, 5, cv2.GC_INIT_WITH_RECT)
mask2 = np.where((mask == 2) | (mask == 0), 0, 1).astype('uint8')
fruit_only = img_rgb * mask2[:, :, np.newaxis]

# 과실 영역 마스크 생성
fruit_mask = np.any(fruit_only != 0, axis=-1).astype(np.uint8)

# LAB 색공간 변환 후 과실 영역의 평균 색상 분석
masked_pixels = fruit_only[fruit_mask == 1]
lab_pixels = cv2.cvtColor(masked_pixels.reshape(-1,1,3), cv2.COLOR_RGB2LAB).reshape(-1,3)

L_mean = np.mean(lab_pixels[:, 0])
A_mean = np.mean(lab_pixels[:, 1])
B_mean = np.mean(lab_pixels[:, 2])

# 숙성도 판별 (기준은 실험적으로 조정할 수 있음)
if L_mean >= 140 and A_mean < 110 and B_mean >= 170 :
    maturity = "Immature" # 미숙 (연녹색 ~ 중간 녹색)
elif 100 < L_mean < 140 and 125 <= A_mean <= 145 and 140 <= B_mean <= 160 :
    maturity = "Mature" # 중간 성숙 (짙은 녹색 ~ 자주빛이 감돌기 시작함)
elif L_mean <= 100 and A_mean > 140 and B_mean < 130 :
    maturity = "Ripe" # 완숙 (짙은 자주색 ~ 보라색)
else:
    maturity = "Uncertain"

# 결과 출력
print("[숙성도 분석 결과]")
print(f"- 평균 L값 (밝기) : {L_mean:.1f}")
print(f"- 평균 a*값 (녹→적) : {A_mean:.1f}")
print(f"- 평균 b*값 (청→황) : {B_mean:.1f}")
print(f"- 숙성도 판단 : {maturity}")

# 시각화
plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.title("Original")
plt.imshow(img_rgb)
plt.axis("off")

plt.subplot(1, 2, 2)
plt.title(f"Fruit _ Maturity : {maturity}")
plt.imshow(fruit_only)
plt.axis("off")
plt.tight_layout()
plt.show()

____________________________________________________________________________________________________

# 요약 :
# 1. GrabCut으로 과실 영역 분리
# 2. 과실의 [가장자리]는 제외
# 3. HSV 색 범위 + GMM 군집화로 병징 후보 검출
# 4. 병징률 계산 및 심각도(4단계) 분류
# 5. 병징 영역의 LAB 색상값 분석
# 6. 결과 이미지(3장) 출력 및 원본, 컨투어 이미지 저장

# 분석할 이미지 경로
IMAGE_PATH = '/content/drive/MyDrive/Colab/ACK2025/passion_fruit/OpenCV_data/C_2.JPG'


# 1. 병징 색상(H, S, V) 범위 설정
# 흰색 반사광(하이라이트)을 잡지 않도록 S, V 범위 조정
HSV_RANGES_TIGHT = [
    ((0, 20, 55), (40, 170, 230)),   # 옅은 베이지 ~ 갈색 계열
    ((160, 10, 55), (180,170, 230)),   # 붉은색 계열
]


# 2. 과실 가장자리 제외
# GrabCut으로 얻은 과실 마스크에서 테두리(가장자리)는 오차가 많으므로 [침식(erode)]하여 제외
EDGE_EXCLUDE_PX_RATIO = 0.01  # 전체 크기의 1% 정도 침식
MIN_EDGE_EXCLUDE_PX = 3       # 최소 3픽셀은 침식


# 3. 반사광 제거(anti-glare)
# 과실 표면 반사(밝고 채도 낮은 부분)는 병징 아님
USE_ANTI_GLARE = True
ANTI_GLARE_PERCENTILE = 98   # 밝기(V) 상위 2%를 반사광으로 간주
ANTI_GLARE_S_LOW = 35        # 채도가 35 미만이면 반사광 후보


# 병징 색상(LAB 공간) 분석
# 밝기(L), 색상 분산 등을 계산하여 병의 진행 정도 추정 가능
def analyze_disease_color_stats(disease_only_rgb, disease_mask) :
    # 병징 픽셀만 뽑기
    masked_pixels = disease_only_rgb[disease_mask == 255]
    if masked_pixels.size == 0 :
        print("병징 픽셀이 없어 분석 불가능!")
        return None, None

    # RGB → LAB 변환
    lab_pixels = cv2.cvtColor(masked_pixels.reshape(-1, 1, 3),
                              cv2.COLOR_RGB2LAB).reshape(-1, 3)
    L_vals, A_vals, B_vals = lab_pixels[:, 0], lab_pixels[:, 1], lab_pixels[:, 2]

    # 통계량 산출
    stats = {
        "L_mean": float(np.mean(L_vals)),   # 평균 밝기
        "L_std":  float(np.std(L_vals)),    # 밝기 분산
        "A_mean": float(np.mean(A_vals)),   # a* (적-녹 색축)
        "A_std":  float(np.std(A_vals)),
        "B_mean": float(np.mean(B_vals)),   # b* (황-청 색축)
        "B_std":  float(np.std(B_vals)),
    }

    # 밝기 기준으로 병징 단계 추정
    L_brightness = stats["L_mean"]
    L_variation  = stats["L_std"]

    if L_brightness > 170 :
        stage = "매우 밝음 (초기 or 비병징 가능성)"
    elif L_brightness > 130 :
        stage = "중간 밝기 (병의 초기 진행 가능성)"
    elif L_brightness > 90 :
        stage = "다소 어두움 (병징이 어느 정도 진행됨)"
    else :
        stage = "어두운 병징 (후기 or 심화 추정)"

    variation_note = "균일함" if L_variation < 10 else "색상 범위가 다양함"

    # 분석 결과 텍스트
    analysis_text = (
        f"- 평균 밝기 (L) : {L_brightness:.1f} → {stage}\n"
        f"- 밝기 분산     : {L_variation:.1f} → {variation_note}\n"
        f"- LAB 평균 색상 : a*={stats['A_mean']:.1f}, b*={stats['B_mean']:.1f}\n"
    )

    return analysis_text, stats


# 4. 이미지 불러오기
img_bgr = cv2.imread(IMAGE_PATH)
if img_bgr is None :
    raise FileNotFoundError(f"이미지를 찾을 수 없음! : {IMAGE_PATH}")
img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
h, w = img_rgb.shape[:2]


# 5. GrabCut으로 과실 영역 분리
# 사각형 ROI(rect)를 지정하여 과실만 분리
margin_x = int(w * 0.04)
margin_y = int(h * 0.01)
rect = (margin_x, margin_y, w - 2*margin_x, h - 2*margin_y)

mask = np.zeros((h, w), np.uint8)
bgdModel = np.zeros((1, 65), np.float64)
fgdModel = np.zeros((1, 65), np.float64)

# GrabCut 실행
cv2.grabCut(img_bgr, mask, rect, bgdModel, fgdModel, 5, cv2.GC_INIT_WITH_RECT)

# 과실 픽셀만 1로 표시
fruit_mask = np.where((mask == cv2.GC_FGD) | (mask == cv2.GC_PR_FGD),
                      1, 0).astype(np.uint8)

# 과실만 남긴 RGB 이미지
fruit_only = img_rgb * fruit_mask[:, :, None]


# 6. 과실 (코어) 마스크 만들기 (가장자리 제외)
edge_px = max(MIN_EDGE_EXCLUDE_PX, int(min(h, w) * EDGE_EXCLUDE_PX_RATIO))
kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
fruit_core_mask = cv2.erode(fruit_mask, kernel, iterations=edge_px)


# 7. HSV + GMM으로 병징 후보 추출
img_hsv = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2HSV)

# HSV 범위로 1차 후보 추출
hsv_mask = np.zeros((h, w), dtype=np.uint8)
for (lo, hi) in HSV_RANGES_TIGHT :
    hsv_mask |= cv2.inRange(img_hsv, np.array(lo), np.array(hi))

# 과실 코어 영역 안으로 제한
hsv_mask = cv2.bitwise_and(hsv_mask, (fruit_core_mask * 255))

# 과실 코어 픽셀로 GMM 군집화
ys, xs = np.where(fruit_core_mask == 1)
fruit_hsv_core = img_hsv[ys, xs].astype(np.float32)

gmm = GaussianMixture(n_components=3, covariance_type='full', random_state=42)
gmm.fit(fruit_hsv_core)
means = gmm.means_

# 각 군집 평균이 HSV 범위 안에 있으면 병징 후보로 지정
def mean_in_any_range(hsv_mean, ranges) :
    H, S, V = hsv_mean
    for (lo, hi) in ranges :
        if (lo[0] <= H <= hi[0]) and (lo[1] <= S <= hi[1]) and (lo[2] <= V <= hi[2]) :
            return True
    return False

disease_comp_ids = [i for i in range(3) if mean_in_any_range(means[i], HSV_RANGES_TIGHT)]

# 군집 결과 → 병징 마스크
labels_core = gmm.predict(fruit_hsv_core)
gmm_mask_core = np.zeros((h, w), dtype=np.uint8)
if len(disease_comp_ids) > 0 :
    disease_idx = np.isin(labels_core, disease_comp_ids)
    gmm_mask_core[ys[disease_idx], xs[disease_idx]] = 255

# HSV와 GMM의 교집합 → 최종 병징 후보
disease_mask_core = cv2.bitwise_and(hsv_mask, gmm_mask_core) if len(disease_comp_ids) > 0 else hsv_mask


# 8. 반사광(anti-glare) 제거
if USE_ANTI_GLARE :
    S = img_hsv[:, :, 1]
    V = img_hsv[:, :, 2]
    core_V = V[fruit_core_mask == 1]
    if core_V.size > 0 :
        v_high = int(np.percentile(core_V, ANTI_GLARE_PERCENTILE))
        glare_mask = ((S < ANTI_GLARE_S_LOW) & (V > v_high)).astype(np.uint8) * 255
        glare_mask = cv2.bitwise_and(glare_mask, fruit_core_mask * 255)
        disease_mask_core = cv2.bitwise_and(disease_mask_core, cv2.bitwise_not(glare_mask))


# 9. 모폴로지 연산으로 노이즈 제거
morph_k = np.ones((3, 3), np.uint8)
disease_mask_core = cv2.morphologyEx(disease_mask_core, cv2.MORPH_OPEN, morph_k, iterations=1)
disease_mask_core = cv2.morphologyEx(disease_mask_core, cv2.MORPH_CLOSE, morph_k, iterations=1)


# 10. 병징률 계산 & 심각도 판정
fruit_pixels   = int(np.count_nonzero(fruit_mask))        # 전체 과실 픽셀 수
disease_pixels = int(np.count_nonzero(disease_mask_core)) # 병징 픽셀 수
disease_ratio  = (disease_pixels / fruit_pixels * 100.0) if fruit_pixels > 0 else 0.0

if disease_ratio < 1 :
    severity = "Very Mild"
elif disease_ratio < 5 :
    severity = "Mild"
elif disease_ratio < 15 :
    severity = "Moderate"
else :
    severity = "Severe"


# 11. 병징 색상 분석 (LAB)
fruit_only_bgr   = cv2.cvtColor(fruit_only, cv2.COLOR_RGB2BGR)
disease_only_bgr = cv2.bitwise_and(fruit_only_bgr, fruit_only_bgr, mask=disease_mask_core)
disease_only_rgb = cv2.cvtColor(disease_only_bgr, cv2.COLOR_BGR2RGB)
analysis_text, stats = analyze_disease_color_stats(disease_only_rgb, disease_mask_core)


# 12. 결과 시각화
# (1) GrabCut 과실 영역
plt.figure(figsize=(8, 6))
plt.title("Fruit Region by GrabCut")
plt.axis('off')
plt.imshow(fruit_only)

# (2) 병징 영역
disease_vis = np.zeros_like(img_rgb)
disease_vis[disease_mask_core > 0] = [255, 0, 0]
plt.figure(figsize=(8, 6))
plt.title("Detected Lesion Region (Core Only)")
plt.axis('off')
plt.imshow(disease_vis)

# (3) 원본 + 컨투어 (과실=청색, 병징=적색)
contour_img = img_bgr.copy()
cnts_fruit, _ = cv2.findContours((fruit_mask*255).astype(np.uint8),
                                 cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
cv2.drawContours(contour_img, cnts_fruit, -1, (255, 0, 0), 2)
cnts_disease, _ = cv2.findContours(disease_mask_core,
                                   cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
cv2.drawContours(contour_img, cnts_disease, -1, (0, 0, 255), 2)

plt.figure(figsize=(8, 6))
plt.title("Contours on Original (Fruit=Blue, Lesion=Red)")
plt.axis('off')
plt.imshow(cv2.cvtColor(contour_img, cv2.COLOR_BGR2RGB))


# 13. 결과 출력 및 저장
print("\n[카운트/비율/판정]")
print(f"- 과실 픽셀 수             : {fruit_pixels}")
print(f"- 병징 픽셀 수(코어 기준)  : {disease_pixels}")
print(f"- 병징률(%)                : {disease_ratio:.3f}")
print(f"- 심각도                   : {severity}")

print("\n[병징 색상 분석(LAB)]")
if analysis_text:
    print(analysis_text.strip())
else:
    print("병징 픽셀이 없어서 색상 분석 불가능!")
